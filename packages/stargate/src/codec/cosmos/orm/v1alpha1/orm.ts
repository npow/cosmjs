/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "cosmos.orm.v1alpha1";

/** TableDescriptor describes an ORM table. */
export interface TableDescriptor {
  /** primary_key defines the primary key for the table. */
  primaryKey?: PrimaryKeyDescriptor;
  /** index defines one or more secondary indexes. */
  index: SecondaryIndexDescriptor[];
  /**
   * id is a non-zero integer ID that must be unique within the
   * tables and singletons in this file. It may be deprecated in the future when this
   * can be auto-generated.
   */
  id: number;
}

/** PrimaryKeyDescriptor describes a table primary key. */
export interface PrimaryKeyDescriptor {
  /**
   * fields is a comma-separated list of fields in the primary key. Spaces are
   * not allowed. Supported field types, their encodings, and any applicable constraints
   * are described below.
   *   - uint32, uint64 are encoded as big-endian fixed width bytes and support
   *   sorted iteration.
   *   - string's are encoded as raw bytes in terminal key segments and null-terminated
   *   in non-terminal segments. Null characters are thus forbidden in strings.
   *   string fields support sorted iteration.
   *   - bytes are encoded as raw bytes in terminal segments and length-prefixed
   *   with a single byte in non-terminal segments. Because of this byte arrays
   *   longer than 255 bytes are unsupported and bytes fields should not
   *   be assumed to be lexically sorted. If you have a byte array longer than
   *   255 bytes that you'd like to index, you should consider hashing it first.
   *   - int32, sint32, int64, sint64 are encoding as fixed width bytes with
   *   an encoding that enables sorted iteration.
   *   - google.protobuf.Timestamp and google.protobuf.Duration are encoded
   *   as 12 bytes using an encoding that enables sorted iteration.
   *   - enum fields are encoded using varint encoding and do not support sorted
   *   iteration.
   *   - bool fields are encoded as a single byte 0 or 1.
   *
   * All other fields types are unsupported in keys including repeated and
   * oneof fields.
   *
   * Primary keys are prefixed by the varint encoded table id and the byte 0x0
   * plus any additional prefix specified by the schema.
   */
  fields: string;
  /**
   * auto_increment specifies that the primary key is generated by an
   * auto-incrementing integer. If this is set to true fields must only
   * contain one field of that is of type uint64.
   */
  autoIncrement: boolean;
  /**
   * references specifies that this primary key references the primary key
   * of another table. See the documentation for the SecondaryIndexDescriptor.references
   * field for more details. An additional constraint placed on primary keys
   * which reference another table is that those references cannot be circular.
   */
  references: string;
}

/** PrimaryKeyDescriptor describes a table secondary index. */
export interface SecondaryIndexDescriptor {
  /**
   * fields is a comma-separated list of fields in the index. The supported
   * field types are the same as those for PrimaryKeyDescriptor.fields.
   * Index keys are prefixed by the varint encoded table id and the varint
   * encoded index id plus any additional prefix specified by the schema.
   *
   * In addition the the field segments, non-unique index keys are suffixed with
   * any additional primary key fields not present in the index fields so that the
   * primary key can be reconstructed. Unique indexes instead of being suffixed
   * store the remaining primary key fields in the value..
   */
  fields: string;
  /**
   * id is a non-zero integer ID that must be unique within the indexes for this
   * table and less than 32768. It may be deprecated in the future when this can
   * be auto-generated.
   */
  id: number;
  /** unique specifies that this an unique index. */
  unique: boolean;
  /**
   * references specifies that this index references another table defined in the same
   * proto file. Currently references are not support to tables with composite
   * primary keys, therefore fields must reference one field and its type must
   * be the same type as the primary key field of the referenced table.
   * References to tables in defined by different proto files are not supported
   * to avoid tight coupling of dependencies. Beyond validating that the reference
   * is valid key constraints are currently not enforced, but references should
   * be used by clients to perform automatic joins.
   */
  references: string;
}

/** TableDescriptor describes an ORM singleton table which has at most one instance. */
export interface SingletonDescriptor {
  /**
   * id is a non-zero integer ID that must be unique within the
   * tables and singletons in this file. It may be deprecated in the future when this
   * can be auto-generated.
   */
  id: number;
}

const baseTableDescriptor: object = { id: 0 };

export const TableDescriptor = {
  encode(message: TableDescriptor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.primaryKey !== undefined) {
      PrimaryKeyDescriptor.encode(message.primaryKey, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.index) {
      SecondaryIndexDescriptor.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.id !== 0) {
      writer.uint32(24).uint32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TableDescriptor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTableDescriptor } as TableDescriptor;
    message.index = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.primaryKey = PrimaryKeyDescriptor.decode(reader, reader.uint32());
          break;
        case 2:
          message.index.push(SecondaryIndexDescriptor.decode(reader, reader.uint32()));
          break;
        case 3:
          message.id = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TableDescriptor {
    const message = { ...baseTableDescriptor } as TableDescriptor;
    message.index = [];
    if (object.primaryKey !== undefined && object.primaryKey !== null) {
      message.primaryKey = PrimaryKeyDescriptor.fromJSON(object.primaryKey);
    } else {
      message.primaryKey = undefined;
    }
    if (object.index !== undefined && object.index !== null) {
      for (const e of object.index) {
        message.index.push(SecondaryIndexDescriptor.fromJSON(e));
      }
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = Number(object.id);
    } else {
      message.id = 0;
    }
    return message;
  },

  toJSON(message: TableDescriptor): unknown {
    const obj: any = {};
    message.primaryKey !== undefined &&
      (obj.primaryKey = message.primaryKey ? PrimaryKeyDescriptor.toJSON(message.primaryKey) : undefined);
    if (message.index) {
      obj.index = message.index.map((e) => (e ? SecondaryIndexDescriptor.toJSON(e) : undefined));
    } else {
      obj.index = [];
    }
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial(object: DeepPartial<TableDescriptor>): TableDescriptor {
    const message = { ...baseTableDescriptor } as TableDescriptor;
    message.index = [];
    if (object.primaryKey !== undefined && object.primaryKey !== null) {
      message.primaryKey = PrimaryKeyDescriptor.fromPartial(object.primaryKey);
    } else {
      message.primaryKey = undefined;
    }
    if (object.index !== undefined && object.index !== null) {
      for (const e of object.index) {
        message.index.push(SecondaryIndexDescriptor.fromPartial(e));
      }
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    } else {
      message.id = 0;
    }
    return message;
  },
};

const basePrimaryKeyDescriptor: object = { fields: "", autoIncrement: false, references: "" };

export const PrimaryKeyDescriptor = {
  encode(message: PrimaryKeyDescriptor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fields !== "") {
      writer.uint32(10).string(message.fields);
    }
    if (message.autoIncrement === true) {
      writer.uint32(16).bool(message.autoIncrement);
    }
    if (message.references !== "") {
      writer.uint32(26).string(message.references);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrimaryKeyDescriptor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePrimaryKeyDescriptor } as PrimaryKeyDescriptor;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields = reader.string();
          break;
        case 2:
          message.autoIncrement = reader.bool();
          break;
        case 3:
          message.references = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrimaryKeyDescriptor {
    const message = { ...basePrimaryKeyDescriptor } as PrimaryKeyDescriptor;
    if (object.fields !== undefined && object.fields !== null) {
      message.fields = String(object.fields);
    } else {
      message.fields = "";
    }
    if (object.autoIncrement !== undefined && object.autoIncrement !== null) {
      message.autoIncrement = Boolean(object.autoIncrement);
    } else {
      message.autoIncrement = false;
    }
    if (object.references !== undefined && object.references !== null) {
      message.references = String(object.references);
    } else {
      message.references = "";
    }
    return message;
  },

  toJSON(message: PrimaryKeyDescriptor): unknown {
    const obj: any = {};
    message.fields !== undefined && (obj.fields = message.fields);
    message.autoIncrement !== undefined && (obj.autoIncrement = message.autoIncrement);
    message.references !== undefined && (obj.references = message.references);
    return obj;
  },

  fromPartial(object: DeepPartial<PrimaryKeyDescriptor>): PrimaryKeyDescriptor {
    const message = { ...basePrimaryKeyDescriptor } as PrimaryKeyDescriptor;
    if (object.fields !== undefined && object.fields !== null) {
      message.fields = object.fields;
    } else {
      message.fields = "";
    }
    if (object.autoIncrement !== undefined && object.autoIncrement !== null) {
      message.autoIncrement = object.autoIncrement;
    } else {
      message.autoIncrement = false;
    }
    if (object.references !== undefined && object.references !== null) {
      message.references = object.references;
    } else {
      message.references = "";
    }
    return message;
  },
};

const baseSecondaryIndexDescriptor: object = { fields: "", id: 0, unique: false, references: "" };

export const SecondaryIndexDescriptor = {
  encode(message: SecondaryIndexDescriptor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fields !== "") {
      writer.uint32(10).string(message.fields);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.unique === true) {
      writer.uint32(24).bool(message.unique);
    }
    if (message.references !== "") {
      writer.uint32(34).string(message.references);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecondaryIndexDescriptor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSecondaryIndexDescriptor } as SecondaryIndexDescriptor;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fields = reader.string();
          break;
        case 2:
          message.id = reader.uint32();
          break;
        case 3:
          message.unique = reader.bool();
          break;
        case 4:
          message.references = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SecondaryIndexDescriptor {
    const message = { ...baseSecondaryIndexDescriptor } as SecondaryIndexDescriptor;
    if (object.fields !== undefined && object.fields !== null) {
      message.fields = String(object.fields);
    } else {
      message.fields = "";
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = Number(object.id);
    } else {
      message.id = 0;
    }
    if (object.unique !== undefined && object.unique !== null) {
      message.unique = Boolean(object.unique);
    } else {
      message.unique = false;
    }
    if (object.references !== undefined && object.references !== null) {
      message.references = String(object.references);
    } else {
      message.references = "";
    }
    return message;
  },

  toJSON(message: SecondaryIndexDescriptor): unknown {
    const obj: any = {};
    message.fields !== undefined && (obj.fields = message.fields);
    message.id !== undefined && (obj.id = message.id);
    message.unique !== undefined && (obj.unique = message.unique);
    message.references !== undefined && (obj.references = message.references);
    return obj;
  },

  fromPartial(object: DeepPartial<SecondaryIndexDescriptor>): SecondaryIndexDescriptor {
    const message = { ...baseSecondaryIndexDescriptor } as SecondaryIndexDescriptor;
    if (object.fields !== undefined && object.fields !== null) {
      message.fields = object.fields;
    } else {
      message.fields = "";
    }
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    } else {
      message.id = 0;
    }
    if (object.unique !== undefined && object.unique !== null) {
      message.unique = object.unique;
    } else {
      message.unique = false;
    }
    if (object.references !== undefined && object.references !== null) {
      message.references = object.references;
    } else {
      message.references = "";
    }
    return message;
  },
};

const baseSingletonDescriptor: object = { id: 0 };

export const SingletonDescriptor = {
  encode(message: SingletonDescriptor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SingletonDescriptor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSingletonDescriptor } as SingletonDescriptor;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SingletonDescriptor {
    const message = { ...baseSingletonDescriptor } as SingletonDescriptor;
    if (object.id !== undefined && object.id !== null) {
      message.id = Number(object.id);
    } else {
      message.id = 0;
    }
    return message;
  },

  toJSON(message: SingletonDescriptor): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial(object: DeepPartial<SingletonDescriptor>): SingletonDescriptor {
    const message = { ...baseSingletonDescriptor } as SingletonDescriptor;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    } else {
      message.id = 0;
    }
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | undefined | Long;
export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
